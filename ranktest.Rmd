---
layout: page
title: Rank tests
---

```{r options, echo=FALSE}
opts_chunk$set(fig.path=paste0("figure/", sub("(.*).Rmd","\\1",basename(knitr:::knit_concord$get('infile'))), "-"))
```

## Wilcoxon signed-rank test

The normal apporximatiion is often useful when analyzing 
high throughput data. However, due to the complexity of the measurement devices it is also common to mistakenly  observe data points generated by an undesired process. For example, a defect on a scanner can produce a hanful of very high intensities. Thus we may have situationst that are approximated by a, for example, 99 data points from a standard normal distribution and one very large number.

```{r}
set.seed(1)
N=25
B=10000
X<-matrix(rnorm(N*B,0,1),B,N)
Y<-matrix(rnorm(N*B,0,1),B,N)
Y[,1]<-5;Y[,2]<-7 ##two outliers
ps=sapply(1:B,function(i){
  return(c(t.test(X[i,],Y[i,])$p.value,
  wilcox.test(X[i,],Y[i,])$p.value))
  }
)
mypar(1,2)
hist(ps[1,],nc=20,xlab="p-values",ylim=c(0,1100),main="t-stat")
hist(ps[2,],nc=20,xlab="p-values",ylim=c(0,1100),main="Wilcoxon")
```

```{r}
i <- which.max((ps[2,]-ps[1,])*(ps[1,]<0.05))
x=X[i,]
y=Y[i,]
stripchart(list(x,y),vertical=TRUE,ylim=c(-7,7),ylab="Observations",pch=21,bg=1,cex=1.25)
abline(h=0)
xrank<-rank(c(x,y))[seq(along=x)]
yrank<-rank(c(x,y))[-seq(along=y)]
stripchart(list(xrank,yrank),vertical=TRUE,ylab="Ranks",pch=21,bg=1,cex=1.25)
ws <- sapply(x,function(z) rank(c(z,y))[1]-1)
text(rep(1.05,length(ws)),xrank,ws)
W <-sum(ws) 
n1<-length(x);n2<-length(y)
Z <- (mean(ws)-n2/2)/ sqrt(n2*(n1+n2+1)/12/n1)
```

```{r}
stripchart(y-x,vertical=TRUE,ylim=c(-8,8))
abline(h=0)
stripchart(rank(abs(y-x))*sign(y-x),vertical=TRUE,ylim=c(-25,25))
abline(h=0)
W=sum(abs(rank(abs(y-x))*sign(y-x)))
```


```{r}
tab=cbind(sign(y-x),abs(y-x),rank(abs(y-x)))
tab=tab[order(tab[,2]),]
```




In statistics we refer these types of points as _outliers_. A small number of outliers can throw of an entire analysis. For example notice how this one point results in the sample mean and sample variace being very far from the 0 and 1 respectively.
```{r}
mean(x)
sd(x)
```
The median, defined as the point having half the data larger and half the data smaller, is summary statistic that is _robust_ to outliers. Note how much close the median is to 0, the center of out actual distribution. 
```{r}
median(x)
```

The median absolute deviace (MAD) is a robust summary for the standard deviation. It is defined by computing the differences between each point and the median and taking the median of their absolute values:
$$
 1.4826 \mbox{median}\{| X_i - \mbox{median}(X_i)|\}
$$
The number $1.4826$ is a scale factor that guarantees an unbiased 
estimate of the actual center. Notice how much closer we are to one with the mad:
```{r}
mad(x)
```

## Spearman correlation
The correlation is also sensitive to outliers. Here we construct a independent list of numbers but for which a simialr mistake was made for the same entry:

```{r}
set.seed(1)
x=c(rnorm(100,0,1)) ##real distribution
x[23] <- 100 ##mistake made in 23th measurement
y=c(rnorm(100,0,1)) ##real distribution
y[23] <- 84 ##similar mistake made in 23th measurement
library(rafalib)
mypar(1,1)
plot(x,y,main=paste0("correlation=",round(cor(x,y),3)),pch=21,bg=1,xlim=c(-3,100),ylim=c(-3,100))
abline(0,1)
```

## Rank tests

We use the same data as in previous module. We have data for two strains of mice which we will refer to as strain 0 and 1. We want to know which genes are differentially expressed.  We extracted RNA from 12 randomly selected mice from each strain [(Kendziorski 2005)](#foot). In one experiment we pooled the RNA from all individuals from each strain and then created 4 replicate samples from this pool. 

```{r}
library(Biobase,quietly=TRUE,verbose=FALSE)
library(genefilter)
library(dagdata)
data(maPooling)
pd=pData(maPooling)
individuals=which(rowSums(pd)==1)
##remove replicates
individuals=individuals[-grep("tr",names(individuals))]
y=exprs(maPooling)[,individuals]
group=factor(as.numeric(grepl("b",names(individuals))))
```

We can compute the sample variance for each gene and compare to the standard deviation obtained with the technical replicates.
```{r}
ind1<-which(group==1);ind0<-which(group==0)
wilcox<-apply(y,1,function(x){
    tmp<-wilcox.test(x[ind1],x[ind0],exact=FALSE)
  c(tmp$statistic,tmp$p.value)
})
ttest<-genefilter::rowttests(y,group)
ind<-which(ttest$p.val<0.05 & wilcox[2,]>0.05)
mypar(3,3)
for(i in ind)
  stripchart(split(y[i,],group),vertical=TRUE,jitter=0.2)
ind
```

## Footnotes <a name="foot"></a>

C. Kendziorski, R. A. Irizarry, K.-S. Chen, J. D. Haag, and M. N. Gould, "On the utility of pooling biological samples in microarray experiments", PNAS, 2005. <http://www.pnas.org/content/102/12/4252.long>

